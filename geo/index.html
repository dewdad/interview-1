<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
  float: left;
}

.area {
  stroke: steelblue;
  fill: #FFF;
}

.area:hover {
  fill: blue;
  cursor: pointer;
}

.legend-text {
  font-size: 0.8em;
}

.active {
  fill: blue !important;
}

.greenest {
  fill: green !important;
}

.reddest {
  fill: red !important;
}

.bar {
  fill: steelblue;
}

.bar.active {
  width: 3px;
}
.bar.greenest {
  width: 3px;
}

.bar.reddest {
  width: 3px;
}

.axis text {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

h2 {
  display:inline-block;
}
</style>

<!-- <script src="//d3js.org/d3.v3.min.js"></script> -->
<script src="./d3.min.js"></script>
<script>
  /*
  lots of help from http://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
  */

  create_dashboard('./../assets/kc-neighborhoods.json', 'Neighborhood', 'neighborhood-button');

  function create_dashboard(data_source, label, button_id) {

    //Load in GeoJSON data
    d3.json(data_source, function(json) {
      d3.selectAll("button").attr("style", "");
      d3.select('#'+button_id).attr("style", "color: blue;")

      // remove anything that might be present (to allow for switching between tracts + neighborhoods)
      d3.selectAll("svg").remove();

      // dynamically determine the commuter attributes by grabbing keys with the pop- prefix
      var pop_keys = Object.keys(json.features[0].properties).filter(function(d) { if(d.startsWith('pop')) {return d;} });

      create_map();
      create_tooltip_chart();
      create_overall_chart();

      // calculate the greenest area?
      var greenest_val = 0;
      var greenest;
      json.features.forEach(function(d) {
        var curr_val = (d.properties['pop-commute-walk'] / d.properties['total']);
        if(curr_val > greenest_val) {
          greenest = d;
          greenest_val = curr_val;
        }
      })
      d3.selectAll(".kc-"+greenest.properties.id).classed("greenest", true);

      // calculate the opposite
      var reddest_val = 0;
      var reddest;
      json.features.forEach(function(d) {
        var curr_val = (d.properties['pop-commute-drive_alone'] / d.properties['total']);
        if(curr_val > reddest_val) {
          reddest = d;
          reddest_val = curr_val;
        }
      })
      d3.selectAll(".kc-"+reddest.properties.id).classed("reddest", true);


      function create_map() {

        //Width and height
        var width = 370;
        var height = 550;

        // create a first guess for the projection
        var center = d3.geo.centroid(json)
        var scale = 150;
        var projection = d3.geo.mercator().scale(scale).center(center);
        //Define path generator
        var path = d3.geo.path()
                        .projection(projection);

        // using the path determine the bounds of the current map and use
        // these to determine better values for the scale and translation
        var bounds = path.bounds(json);
        var hscale = scale * width / (bounds[1][0] - bounds[0][0]);
        var vscale = scale * height / (bounds[1][1] - bounds[0][1]);
        var scale = (hscale < vscale) ? hscale : vscale;
        var offset = [width - (bounds[0][0] + bounds[1][0]) / 5.8,
                         height - (bounds[0][1] + bounds[1][1]) / 1.65];

        // new projection
        projection = d3.geo.mercator().center(center)
         .scale(scale * 0.96).translate(offset);
        path = path.projection(projection);

        //Create SVG element
        var svg = d3.select("body").append("svg")
                   .attr("width", width)
                   .attr("height", height)

        //Bind data and create one path per GeoJSON feature
        var shape = svg.selectAll("path")
          .data(json.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("class", function(d) { return "area kc-"+d.properties.id });

        shape.on("mouseover", function(d) {
            d3.selectAll(".active").classed("active", false);
            d3.selectAll(".kc-"+d.properties.id).classed("active", true);
            update_bar_chart(d.properties);
          })


        //legend stuff
        var legend_data = [
          { 'name': "Highest % Walking", 'color': 'green' },
          { 'name': "Highest % Driving Alone", 'color': 'red' }
        ]
        var legend = svg.selectAll(".legend")
            .data(legend_data)
          .enter().append("g")
            .attr("class", "legend")
            .attr("transform", function(d, i) { return "translate(0," + ((height - 40) - (i * 20)) + ")"; });

        legend.append("rect")
            .attr("x", 0)
            .attr("width", 18)
            .attr("height", 18)
            .style("fill", function(d) { return d['color']; });

        legend.append("text")
            .attr("x", 20)
            .attr("y", 9)
            .attr("class", 'legend-text')
            .attr("dy", ".35em")
            .style("text-anchor", "start")
            .text(function(d) { return d['name'] });
      }

      // barchart that shows commuter attributes for a given map area
      // effectively a super fancy tooltip
      function create_tooltip_chart() {

        ///////////////
        // Bar stuff
        var data = json.features;
        ///////////////////////
        // Chart Size Setup
        var margin = { top: 35, right: 0, bottom: 30, left: 40 };

        var width = 600 - margin.left - margin.right;
        var chart_height = 275 - margin.top - margin.bottom;

        var chart = d3.select("body").append("svg").attr('class',"chart")
            .attr("width", 600)
            .attr("height", 275)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        ///////////////////////
        // Scales
        var x = d3.scale.ordinal()
            .domain(pop_keys)
            .rangeRoundBands([0, width], .1);

        var y = d3.scale.linear()
            .domain([0, d3.max(data, function(d) { return parseInt(d.properties['pop-commute-drive_alone']); }) * 1.1])
            .range([chart_height, 0]);

        ///////////////////////
        // Axis
        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left");

        chart.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + chart_height + ")")
            .call(xAxis);

        chart.append("g")
            .attr("class", "y axis")
            .call(yAxis);

        var placeholder_text = ["Hover over the map","or the bars below","to explore the data!"];
        var placeholder = chart.selectAll(".placeholder").data(placeholder_text);

        placeholder.enter().append("text")
            .text(function(d) { return d })
            .attr("text-anchor", "middle")
            .attr("font-size", 40)
            .attr("y", function(d, i) { return 50 + 35 * i; })
            .attr("x", width / 2.0);

        // for anything that needs to update
        update_bar_chart = function(bar_data) {
          placeholder.remove();

          ///////////////////////
          // Title
          var title = chart.selectAll(".graph-title").data([bar_data])

          title.enter().append("text")
            .attr("text-anchor", "middle")
            .attr("class", "graph-title")
            .attr("y", -10)
            .attr("x", width / 2.0);

          title.transition()
            .text(function(d) {
              return label + ": " + d.shid.slice(d.shid.lastIndexOf(":") + 1);
            });


          // transform from obj to array for d3
          var temp_data = [];
          for(var key in bar_data) {
            if(pop_keys.indexOf(key) > -1) {
              temp_data.push({name: key, value: bar_data[key]});
            }
          }

          ///////////////////////
          // Bars
          var bar = chart.selectAll(".bar")
              .data(temp_data)

          bar.enter().append("rect")
              .attr("class", "bar")
              .attr("x", function(d) { return x(d.name); })
              .attr("y", chart_height)
              .attr("width", x.rangeBand())
              .attr("height", 0);

          bar.transition()
              .duration(300)
              .ease("sine")
              .attr("y", function(d) { return y(parseInt(d.value)); })
              .attr("height", function(d) { return chart_height - y(parseInt(d.value)); })

          bar.exit().remove()
        }
      }

      // show distribution of overall commuter by car
      // to provide context for the tooltip bars
      function create_overall_chart() {
        var data = json.features;

        data.forEach(function(d) {
          var new_val = 0;
          for(var key in d.properties) {
            if(pop_keys.indexOf(key) > -1) {
              new_val += d.properties[key];
            }
          }
          d.properties['total'] = new_val;
        });

        data = data.sort(function(a, b) {
          return parseInt(a.properties['total']) - parseInt(b.properties['total'])
        })

        ///////////////////////
        // Chart Size Setup
        var margin = { top: 35, right: 0, bottom: 30, left: 40 };

        var width = 600 - margin.left - margin.right;
        var chart_height = 275 - margin.top - margin.bottom;

        var chart = d3.select("body").append("svg").attr('class',"totals chart")
            .attr("width", 600)
            .attr("height", 275)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        ///////////////////////
        // Scales
        var x = d3.scale.ordinal()
            .domain(data.map(function(d) { return d.properties.id; }))
            .rangeBands([0, width]);

        var y = d3.scale.log()
            .domain([1, d3.max(data, function(d) { return d.properties['total'] })])
            .range([chart_height, 0]);

        ///////////////////////
        // Axis
        var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

        var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .tickFormat(function (d) {
              return y.tickFormat(4,d3.format(",d"))(d)
            });

        chart.append("g")
            .attr("class", "y axis")
            .call(yAxis);

        ///////////////////////
        // Title
        chart.append("text")
          .text(label + 's Sorted by Commuter Population Size')
          .attr("text-anchor", "middle")
          .attr("class", "graph-title")
          .attr("y", -10)
          .attr("x", width / 2.0);

        ///////////////////////
        // Bars
        var bar = chart.selectAll(".bar")
            .data(data)

        bar.enter().append("rect")
            .attr("class", function(d) { return "bar kc-" + d.properties.id})
            .attr("x", function(d) { return x(d.properties.id); })
            .attr("y", chart_height)
            .attr("width", 2)
            .attr("height", 0);

        bar.transition()
            .duration(1500)
            .ease("elastic")
            .attr("y", function(d) { return y(parseInt(d.properties['total'])); })
            .attr("height", function(d) { return chart_height - y(parseInt(d.properties['total'])); })

        bar.on("mouseover", function(d) {
            d3.selectAll(".active").classed("active", false);
            d3.selectAll(".kc-"+d.properties.id).classed("active", true);
            update_bar_chart(d.properties);
          })

      }
    });
  }
</script>

<body>
  <div class='header'>
    <h2>Kansas City Commuter Data</h2>
    <button id='tract-button' onclick="create_dashboard('./../assets/kc-tracts.json', 'Census Tract', 'tract-button')")>Tracts</button>
    <button id='neighborhood-button' onclick="create_dashboard('./../assets/kc-neighborhoods.json', 'Neighorhood', 'neighborhood-button')">Neighborhoods</button>
  </div>
</body>
