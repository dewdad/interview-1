<!DOCTYPE html>
<meta charset="utf-8">
<style>
svg {
  float: left;
}
.area {
  stroke: steelblue;
  fill: #FFF;
}

.area:hover {
  fill: blue;
  cursor: pointer;
}

.active {
  fill: blue !important;
}

.bar {
  fill: steelblue;
}

.bar.active {
  width: 3px;
}

.axis text {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}
</style>

<!-- <script src="//d3js.org/d3.v3.min.js"></script> -->
<script src="./d3.min.js"></script>
<script>
  /*
  lots of help from http://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
  */

  //Load in GeoJSON data
  d3.json("./../assets/kc-neighborhoods.json", function(json) {
    create_map();
    create_tooltip_chart();
    create_overall_chart();

    function create_map() {

      //Width and height
      var width = 470;
      var height = 550;

      // create a first guess for the projection
      var center = d3.geo.centroid(json)
      var scale = 150;
      var projection = d3.geo.mercator().scale(scale).center(center);
      //Define path generator
      var path = d3.geo.path()
                      .projection(projection);

      // using the path determine the bounds of the current map and use
      // these to determine better values for the scale and translation
      var bounds = path.bounds(json);
      var hscale = scale * width / (bounds[1][0] - bounds[0][0]);
      var vscale = scale * height / (bounds[1][1] - bounds[0][1]);
      var scale = (hscale < vscale) ? hscale : vscale;
      var offset = [width - (bounds[0][0] + bounds[1][0]) / 4,
                       height - (bounds[0][1] + bounds[1][1]) / 1.65];

      // new projection
      projection = d3.geo.mercator().center(center)
       .scale(scale * 0.96).translate(offset);
      path = path.projection(projection);

      //Create SVG element
      var svg = d3.select(".chart")
                 .attr("width", width)
                 .attr("height", height)

      //Bind data and create one path per GeoJSON feature
      var shape = svg.selectAll("path")
        .data(json.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("class", function(d) { return "area kc-"+d.properties.id });

      shape.on("mouseover", function(d) {
          d3.selectAll(".active").classed("active", false);
          d3.selectAll(".kc-"+d.properties.id).classed("active", true);
          update_bar_chart(d.properties);
        })
    }

    // barchart that shows commuter attributes for a given map area
    // effectively a super fancy tooltip
    function create_tooltip_chart() {
      // dynamically determine the commuter attributes by grabbing keys with the pop- prefix
      var pop_keys = Object.keys(json.features[0].properties).filter(function(d) { if(d.startsWith('pop')) {return d;} });

      ///////////////
      // Bar stuff
      var data = json.features;
      ///////////////////////
      // Chart Size Setup
      var margin = { top: 35, right: 0, bottom: 30, left: 40 };

      var width = 560 - margin.left - margin.right;
      var chart_height = 275 - margin.top - margin.bottom;

      var chart = d3.select("body").append("svg").attr('class',"chart")
          .attr("width", 560)
          .attr("height", 275)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      ///////////////////////
      // Scales
      var x = d3.scale.ordinal()
          .domain(pop_keys)
          .rangeRoundBands([0, width], .1);

      var y = d3.scale.linear()
          .domain([0, d3.max(data, function(d) { return parseInt(d.properties['pop-commute-drive_alone']); }) * 1.1])
          .range([chart_height, 0]);

      ///////////////////////
      // Axis
      var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom");

      var yAxis = d3.svg.axis()
          .scale(y)
          .orient("left");

      chart.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + chart_height + ")")
          .call(xAxis);

      chart.append("g")
          .attr("class", "y axis")
          .call(yAxis);

      // for anything that needs to update
      update_bar_chart = function(bar_data) {
        ///////////////////////
        // Title
        var title = chart.selectAll(".graph-title").data([bar_data])

        title.enter().append("text")
          .attr("text-anchor", "middle")
          .attr("class", "graph-title")
          .attr("y", -10)
          .attr("x", width / 2.0);

        title.transition()
          .text(function(d) {
            return d.shid.slice(d.shid.lastIndexOf(":") + 1);
          });


        // transform from obj to array for d3
        var temp_data = [];
        for(var key in bar_data) {
          if(pop_keys.indexOf(key) > -1) {
            temp_data.push({name: key, value: bar_data[key]});
          }
        }

        ///////////////////////
        // Bars
        var bar = chart.selectAll(".bar")
            .data(temp_data)

        bar.enter().append("rect")
            .attr("class", "bar")
            .attr("x", function(d) { return x(d.name); })
            .attr("y", chart_height)
            .attr("width", x.rangeBand())
            .attr("height", 0);

        bar.transition()
            .duration(300)
            .ease("sine")
            .attr("y", function(d) { return y(parseInt(d.value)); })
            .attr("height", function(d) { return chart_height - y(parseInt(d.value)); })

        bar.exit().remove()
      }
    }

    // show distribution of overall commuter by car
    // for some context?
    // TODO: make the bars highlight depending on the area
    // TOOD: should this be totals rather than commuter by car?
    function create_overall_chart() {
      var data = json.features;

      data = data.sort(function(a, b) {
        return parseInt(a.properties['pop-commute-drive_alone']) - parseInt(b.properties['pop-commute-drive_alone'])
      })

      ///////////////////////
      // Chart Size Setup
      var margin = { top: 35, right: 0, bottom: 30, left: 40 };

      var width = 560 - margin.left - margin.right;
      var chart_height = 275 - margin.top - margin.bottom;

      var chart = d3.select("body").append("svg").attr('class',"totals chart")
          .attr("width", 560)
          .attr("height", 275)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      ///////////////////////
      // Scales
      var x = d3.scale.ordinal()
          .domain(data.map(function(d) { return d.properties.id; }))
          .rangeRoundBands([0, width], .1);

      var y = d3.scale.linear()
          .domain([0, d3.max(data, function(d) { return d.properties['pop-commute-drive_alone'] })* 1.1])
          .range([chart_height, 0]);

      ///////////////////////
      // Axis
      var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom");

      var yAxis = d3.svg.axis()
          .scale(y)
          .orient("left");

      chart.append("g")
          .attr("class", "y axis")
          .call(yAxis);

      ///////////////////////
      // Title
      chart.append("text")
        .text('Commuters that drive alone')
        .attr("text-anchor", "middle")
        .attr("class", "graph-title")
        .attr("y", -10)
        .attr("x", width / 2.0);

      ///////////////////////
      // Bars
      var bar = chart.selectAll(".bar")
          .data(data)

      bar.enter().append("rect")
          .attr("class", function(d) { return "bar kc-"+d.properties.id})
          .attr("x", function(d) { return x(d.properties.id); })
          .attr("y", chart_height)
          .attr("width", 2)
          .attr("height", 0);

      bar.transition()
          .duration(1500)
          .ease("elastic")
          .attr("y", function(d) { return y(parseInt(d.properties['pop-commute-drive_alone'])); })
          .attr("height", function(d) { return chart_height - y(parseInt(d.properties['pop-commute-drive_alone'])); })

      bar.on("mouseover", function(d) {
          d3.selectAll(".active").classed("active", false);
          d3.selectAll(".kc-"+d.properties.id).classed("active", true);
          update_bar_chart(d.properties);
        })

    }

  });
</script>

<body>
  <svg class="chart"></svg>
</body>
